# Q1
## How many c source are listed ?

there are 35 source in io_uring folder:
## advise.c
## alloc_chace.c
## cancel.c
## epol.c
## eventfd.c
## fdinfo.c
## filetable.c
## fs.c
## futex.c

## io-wq.c
## io_uring.c
## kbuf.c
## memmap.c
## msg_ring.c
## napi.c
## net.c
## nop.c
## notif.c

## opdef.c
## openclose.c
## poll.c
## register.c
## rsrc.c
## rw.c
## splice.c
## sqpoll.c
## statx.c

## sync.c
Implements fsync, sync_file_range, and fallocate support for io_uring. Uses a shared io_sync struct to hold parameters like offset, length, and flags. Each operation parses and validates the SQE, then calls the corresponding VFS function. All operations require blocking context and are marked with REQ_F_FORCE_ASYNC.

## tctx.c
Manages task-specific io_uring context, including initialization, management, and cleanup. It allocates resources like work queues and reference counters for tasks and handles task-ring associations. The file also manages registered file descriptors to reduce overhead during io_uring operations, using synchronization mechanisms like mutexes and atomic counters for resource handling.

## timeout.c
This file handles timeout management for io_uring requests. It defines structures and functions to manage timeouts, including linked timeouts, multiple shot timeouts, and timeout cancellation. Key components include functions for starting, updating, completing, and flushing timeouts, as well as handling linked request failures. The hrtimer mechanisms are used for managing precise timeout events.

## truncate.c
This file handles file truncation in io_uring. io_ftruncate_prep prepares the truncation request, validating input and extracting the truncation length. io_ftruncate performs the truncation using the do_ftruncate system call, managing error checking and result setting. It integrates with the file management system and includes relevant kernel headers.

## uring_cmd.c
This file handles the execution and cleanup of io_uring commands, particularly asynchronous commands. It defines functions for preparing, executing, and completing commands with support for cancellation, handling socket options (GET/SET), and managing asynchronous data. Key operations include setting up command data, submitting commands, and handling deferred completions. It also provides functions for canceling and cleaning up commands, managing command-related resources, and interacting with sockets for network operations.

## waitid.c
This file manages asynchronous waitid notifications in io_uring. It handles request setup, cancellation, and completion for waitid, synchronizing with wait queues and ensuring safe resource cleanup. The file supports both regular and compatibility systems for signal information, and provides functions for reference management, process status changes, and handling cancellations.

## xattr.c
This file manages asynchronous file extended attribute (xattr) operations in io_uring. It prepares and executes getxattr and setxattr requests, handling both file-based and path-based operations. The file is responsible for setting up, cleaning up, and managing memory for xattr contexts, ensuring proper error handling and resource management during attribute retrieval or modification.

## zcrx.c
This file manages Zero-Copy Receive (ZCRX) operations in io_uring, including setting up receive buffers and interface queues. It handles registration and unregistration of ZCRX interfaces, and provides functions for receiving data through sockets. The file uses conditional compilation to enable ZCRX features based on kernel configuration.

## How many internal headers are listed

there are 37 headers :
## advise.h
## alloc_chace.h
## cancel.h
## epol.h
## eventfd.h
## fdinfo.h
## filetable.h
## fs.h
## futex.h
## io-wq.h



## sync.h
int io_sfr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_sync_file_range(struct io_kiocb *req, unsigned int issue_flags);

int io_fsync_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_fsync(struct io_kiocb *req, unsigned int issue_flags);

int io_fallocate(struct io_kiocb *req, unsigned int issue_flags);
int io_fallocate_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);

## tctx.h
int io_uring_alloc_task_context(struct task_struct *task,
				struct io_ring_ctx *ctx);
void io_uring_del_tctx_node(unsigned long index);
int __io_uring_add_tctx_node(struct io_ring_ctx *ctx);
int __io_uring_add_tctx_node_from_submit(struct io_ring_ctx *ctx);
void io_uring_clean_tctx(struct io_uring_task *tctx);

void io_uring_unreg_ringfd(void);
int io_ringfd_register(struct io_ring_ctx *ctx, void __user *__arg,
		       unsigned nr_args);
int io_ringfd_unregister(struct io_ring_ctx *ctx, void __user *__arg,
			 unsigned nr_args);

static inline int io_uring_add_tctx_node(struct io_ring_ctx *ctx)
{
	struct io_uring_task *tctx = current->io_uring;

	if (likely(tctx && tctx->last == ctx))
		return 0;

	return __io_uring_add_tctx_node_from_submit(ctx);
}


## timeout.h
static inline struct io_kiocb *io_disarm_linked_timeout(struct io_kiocb *req)
{
	struct io_kiocb *link = req->link;

	if (link && link->opcode == IORING_OP_LINK_TIMEOUT)
		return __io_disarm_linked_timeout(req, link);

	return NULL;
}
__cold void io_flush_timeouts(struct io_ring_ctx *ctx);
int io_timeout_cancel(struct io_ring_ctx *ctx, struct io_cancel_data *cd);
__cold bool io_kill_timeouts(struct io_ring_ctx *ctx, struct io_uring_task *tctx,
			     bool cancel_all);
void io_queue_linked_timeout(struct io_kiocb *req);
void io_disarm_next(struct io_kiocb *req);

int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_link_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_timeout(struct io_kiocb *req, unsigned int issue_flags);
int io_timeout_remove_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_timeout_remove(struct io_kiocb *req, unsigned int issue_flags);

## truncate.h
int io_ftruncate_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_ftruncate(struct io_kiocb *req, unsigned int issue_flags);

## uring_cmd.h
int io_uring_cmd(struct io_kiocb *req, unsigned int issue_flags);
int io_uring_cmd_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
void io_uring_cmd_cleanup(struct io_kiocb *req);

bool io_uring_try_cancel_uring_cmd(struct io_ring_ctx *ctx,
				   struct io_uring_task *tctx, bool cancel_all);

void io_cmd_cache_free(const void *entry);

int io_uring_cmd_import_fixed_vec(struct io_uring_cmd *ioucmd,
				  const struct iovec __user *uvec,
				  size_t uvec_segs,
				  int ddir, struct iov_iter *iter,
				  unsigned issue_flags);

## waitid.h
int io_waitid_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_waitid(struct io_kiocb *req, unsigned int issue_flags);
int io_waitid_cancel(struct io_ring_ctx *ctx, struct io_cancel_data *cd,
		     unsigned int issue_flags);
bool io_waitid_remove_all(struct io_ring_ctx *ctx, struct io_uring_task *tctx,
			  bool cancel_all);

## xattr.h
void io_xattr_cleanup(struct io_kiocb *req);

int io_fsetxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_fsetxattr(struct io_kiocb *req, unsigned int issue_flags);

int io_setxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_setxattr(struct io_kiocb *req, unsigned int issue_flags);

int io_fgetxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_fgetxattr(struct io_kiocb *req, unsigned int issue_flags);

int io_getxattr_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
int io_getxattr(struct io_kiocb *req, unsigned int issue_flags);

## zcrx.h
#if defined(CONFIG_IO_URING_ZCRX)
int io_register_zcrx_ifq(struct io_ring_ctx *ctx,
			 struct io_uring_zcrx_ifq_reg __user *arg);
void io_unregister_zcrx_ifqs(struct io_ring_ctx *ctx);
void io_shutdown_zcrx_ifqs(struct io_ring_ctx *ctx);
int io_zcrx_recv(struct io_kiocb *req, struct io_zcrx_ifq *ifq,
		 struct socket *sock, unsigned int flags,
		 unsigned issue_flags, unsigned int *len);
#else
static inline int io_register_zcrx_ifq(struct io_ring_ctx *ctx,
					struct io_uring_zcrx_ifq_reg __user *arg)
{
	return -EOPNOTSUPP;
}
static inline void io_unregister_zcrx_ifqs(struct io_ring_ctx *ctx)
{
}
static inline void io_shutdown_zcrx_ifqs(struct io_ring_ctx *ctx)
{
}
static inline int io_zcrx_recv(struct io_kiocb *req, struct io_zcrx_ifq *ifq,
			       struct socket *sock, unsigned int flags,
			       unsigned issue_flags, unsigned int *len)
{
	return -EOPNOTSUPP;
}
#endif

int io_recvzc(struct io_kiocb *req, unsigned int issue_flags);
int io_recvzc_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);

#endif