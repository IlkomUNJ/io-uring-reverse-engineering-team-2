# Q1
## How many c source are listed ?

there are 35 source in io_uring folder:
### advise.c
store structure io_fadvise that have the same value with io_madvise, The difference between io_fadvise and io_madvise is u64 data type name. and there are some function related to io_madvise and io_fadvise. there is a function which will use if advise config and MMU config is defined. If i summarize roughly, io_madvise function work if the CONFIG_ADVISE_SYSCALLS and CONFIG_MMU is defined. otherwise fadvise didn't need to define them to use the function.


### alloc_chace.c
store the full function for organizing alloc chace which include init, new, and free. The function works as it's name implies.


### cancel.c
Contain cancelling procedure for io_uring. There is procedure cancelling with will run with matches criteria, and there are some helper function related to some function. This code is support async and sync operation paths. Including poll cancel, waitid cancel, futex cancel. furthermore, those function must be studied more deeply.


### epol.c
This file contain only used if the flag is set. Store io_epoll struct which initiatet with function io_kiocb_to_cmd. The function handle io_epoll_ctl.


### eventfd.c
Store io_ev_fd structure and an enum with value IO_EVENTFD_OP_SIGNAL_BIT. Control eventfd with io_eventfd_register to sets an eventfd and remove with io_eventfd_unregister. Send a signal with certain condition then call the rcu and free ev_fd after send.


### fdinfo.c
Active if there is flag set (CONFIG_PROC_FS). Showing cred and fdinfo another function is tracking the show of fdinfo. 


### filetable.c
The code is part of a system that manages files in the context of `io_uring`. It deals with allocating and managing file slots, tracking which files are used, and handling operations related to those files. The `io_file_bitmap_get` function searches for an available file slot, while `io_alloc_file_tables` and `io_free_file_tables` handle the allocation and freeing of file tables. The `io_install_fixed_file` and `__io_fixed_fd_install` functions are responsible for installing files into fixed slots, and `io_fixed_fd_remove` removes files from those slots. Finally, `io_register_file_alloc_range` allows for defining a range of file slots that can be allocated. These functions help manage file resources in `io_uring` efficiently, allowing users to interact with files in a non-blocking way while ensuring proper resource management and cleanup.


### fs.c
This code seems to handle file operations like renaming, deleting, making directories, and creating links, using io_uring. It defines some structures like io_rename, io_unlink, io_mkdir, and io_link, which help group the necessary information to perform these operations. Each of them keeps track of things like file descriptors, file names, and extra options like flags or permissions. There are functions to prepare each operation (like io_renameat_prep) that extract inputs and set things up, and others to actually do the operation (like io_renameat) using lower-level functions like do_renameat2. Cleanup functions (like io_renameat_cleanup) are used to free any memory or resources that were temporarily needed. The naming of the functions and structures helps tell you what part of the file system task they deal with, and most functions follow a similar pattern: prepare, act, then clean up.


### futex.c
The io_futex_cancel function is responsible for canceling in-flight futex-related I/O operations submitted via io_uring. Based on the name, it handles cleanup and notification for asynchronous futex operations that may still be pending in the kernel. It takes a pointer to the io_ring_ctx (the per-ring context structure managing io_uring state) and an io_cancel_data structure, which holds identifying information for the request to be canceled. It searches the ctx->futex_list, which is a hash list of all futex-related io_kiocb requests (the internal representation of an I/O request in io_uring), checking for a match based on user data or broader cancelation flags (IORING_ASYNC_CANCEL_ANY, IORING_ASYNC_CANCEL_ALL). Upon finding a matching request, it invokes __io_futex_cancel, which either dequeues the futex wait (futex_unqueue) or marks a futexv (vector wait) as claimed and completed. The cancelation completes the request with -ECANCELED and schedules any task work via io_req_task_work_add. Relevant structures include struct io_kiocb, struct io_futex, and struct io_futex_data (which embeds a struct futex_q representing the kernel futex waiter), showing how each async futex request is tracked, canceled, and cleaned up within io_uring's framework.


## io-wq.c
## io_uring.c
## kbuf.c
## memmap.c
## msg_ring.c
## napi.c
## net.c
## nop.c
## notif.c

## opdef.c
## openclose.c
## poll.c
## register.c
## rsrc.c
## rw.c
## splice.c
## sqpoll.c
## statx.c

## sync.c
## tctx.c
## timeout.c
## truncate.c
## uring_cmd.c
## waitid.c
## xattr.c
## zcrx.c


## How many internal headers are listed

there are 37 headers :
### advise.h
- int io_madvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_madvise(struct io_kiocb *req, unsigned int issue_flags);

- int io_fadvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_fadvise(struct io_kiocb *req, unsigned int issue_flags);


### alloc_chace.h
- void io_alloc_cache_free(struct io_alloc_cache *cache,
			 void (*free)(const void *));
- bool io_alloc_cache_init(struct io_alloc_cache *cache,
			 unsigned max_nr, unsigned int size,
			 unsigned int init_bytes);
- void *io_cache_alloc_new(struct io_alloc_cache *cache, gfp_t gfp);
- static inline void io_alloc_cache_kasan(struct iovec **iov, int *nr)
- static inline bool io_alloc_cache_put(struct io_alloc_cache *cache,
				      void *entry)
- static inline void *io_alloc_cache_get(struct io_alloc_cache *cache)
- static inline void *io_cache_alloc(struct io_alloc_cache *cache, gfp_t gfp)



### cancel.h
- int io_async_cancel_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_async_cancel(struct io_kiocb *req, unsigned int issue_flags);
- int io_try_cancel(struct io_uring_task *tctx, struct io_cancel_data *cd,
		  unsigned int issue_flags);
- int io_sync_cancel(struct io_ring_ctx *ctx, void __user *arg);
- bool io_cancel_req_match(struct io_kiocb *req, struct io_cancel_data *cd);
- static inline bool io_cancel_match_sequence(struct io_kiocb *req, int sequence)


### epol.h
- int io_epoll_ctl_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_epoll_ctl(struct io_kiocb *req, unsigned int issue_flags);


### eventfd.h
- int io_eventfd_register(struct io_ring_ctx *ctx, void __user *arg,
			unsigned int eventfd_async);
- int io_eventfd_unregister(struct io_ring_ctx *ctx);

- void io_eventfd_flush_signal(struct io_ring_ctx *ctx);
- void io_eventfd_signal(struct io_ring_ctx *ctx);


### fdinfo.h
- void io_uring_show_fdinfo(struct seq_file *m, struct file *f);


### filetable.h
- bool io_alloc_file_tables(struct io_ring_ctx *ctx, struct io_file_table *table, unsigned nr_files);
- void io_free_file_tables(struct io_ring_ctx *ctx, struct io_file_table *table);

- int io_fixed_fd_install(struct io_kiocb *req, unsigned int issue_flags,
			struct file *file, unsigned int file_slot);
- int __io_fixed_fd_install(struct io_ring_ctx *ctx, struct file *file,
				unsigned int file_slot);
- int io_fixed_fd_remove(struct io_ring_ctx *ctx, unsigned int offset);

- int io_register_file_alloc_range(struct io_ring_ctx *ctx,
				 struct io_uring_file_index_range __user *arg);

- io_req_flags_t io_file_get_flags(struct file *file);

- static inline void io_file_bitmap_clear(struct io_file_table *table, int bit)
- static inline void io_file_bitmap_set(struct io_file_table *table, int bit)
- static inline unsigned int io_slot_flags(struct io_rsrc_node *node)
- static inline struct file *io_slot_file(struct io_rsrc_node *node)
- static inline void io_fixed_file_set(struct io_rsrc_node *node,
				     struct file *file)
- static inline void io_file_table_set_alloc_range(struct io_ring_ctx *ctx,
						 unsigned off, unsigned len)


### fs.h
- int io_renameat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_renameat(struct io_kiocb *req, unsigned int issue_flags);
- void io_renameat_cleanup(struct io_kiocb *req);

- int io_unlinkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_unlinkat(struct io_kiocb *req, unsigned int issue_flags);
- void io_unlinkat_cleanup(struct io_kiocb *req);

- int io_mkdirat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_mkdirat(struct io_kiocb *req, unsigned int issue_flags);
- void io_mkdirat_cleanup(struct io_kiocb *req);

- int io_symlinkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_symlinkat(struct io_kiocb *req, unsigned int issue_flags);

- int io_linkat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_linkat(struct io_kiocb *req, unsigned int issue_flags);
- void io_link_cleanup(struct io_kiocb *req);


### futex.h
- int io_futex_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_futexv_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe);
- int io_futex_wait(struct io_kiocb *req, unsigned int issue_flags);
- int io_futexv_wait(struct io_kiocb *req, unsigned int issue_flags);
- int io_futex_wake(struct io_kiocb *req, unsigned int issue_flags);
- int io_futex_cancel(struct io_ring_ctx *ctx, struct io_cancel_data *cd,
		    unsigned int issue_flags);
- bool io_futex_remove_all(struct io_ring_ctx *ctx, struct io_uring_task *tctx,
			 bool cancel_all);
- bool io_futex_cache_init(struct io_ring_ctx *ctx);
- void io_futex_cache_free(struct io_ring_ctx *ctx);
- static inline int io_futex_cancel(struct io_ring_ctx *ctx,
				  struct io_cancel_data *cd,
				  unsigned int issue_flags)
- static inline bool io_futex_remove_all(struct io_ring_ctx *ctx,
				       struct io_uring_task *tctx, bool cancel_all)
- static inline bool io_futex_cache_init(struct io_ring_ctx *ctx)
- static inline void io_futex_cache_free(struct io_ring_ctx *ctx)



### io-wq.h
